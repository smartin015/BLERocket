// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGE_MESSAGE_H_
#define FLATBUFFERS_GENERATED_MESSAGE_MESSAGE_H_

#include "flatbuffers/flatbuffers.h"

#include "game_generated.h"
#include "nav_generated.h"

namespace message {

struct Message;
struct MessageT;

struct Ship;
struct ShipT;

struct Part;
struct PartT;

enum Type {
  Type_give = 0,
  Type_make = 1,
  Type_launch = 2,
  Type_race = 3,
  Type_trade = 4,
  Type_explore = 5,
  Type_score = 6,
  Type_MIN = Type_give,
  Type_MAX = Type_score
};

inline const Type (&EnumValuesType())[7] {
  static const Type values[] = {
    Type_give,
    Type_make,
    Type_launch,
    Type_race,
    Type_trade,
    Type_explore,
    Type_score
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[] = {
    "give",
    "make",
    "launch",
    "race",
    "trade",
    "explore",
    "score",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_give || e > Type_score) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

enum UMessage {
  UMessage_NONE = 0,
  UMessage_status = 1,
  UMessage_ship = 2,
  UMessage_part = 3,
  UMessage_MIN = UMessage_NONE,
  UMessage_MAX = UMessage_part
};

inline const UMessage (&EnumValuesUMessage())[4] {
  static const UMessage values[] = {
    UMessage_NONE,
    UMessage_status,
    UMessage_ship,
    UMessage_part
  };
  return values;
}

inline const char * const *EnumNamesUMessage() {
  static const char * const names[] = {
    "NONE",
    "status",
    "ship",
    "part",
    nullptr
  };
  return names;
}

inline const char *EnumNameUMessage(UMessage e) {
  if (e < UMessage_NONE || e > UMessage_part) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUMessage()[index];
}

template<typename T> struct UMessageTraits {
  static const UMessage enum_value = UMessage_NONE;
};

template<> struct UMessageTraits<game::Status> {
  static const UMessage enum_value = UMessage_status;
};

template<> struct UMessageTraits<Ship> {
  static const UMessage enum_value = UMessage_ship;
};

template<> struct UMessageTraits<Part> {
  static const UMessage enum_value = UMessage_part;
};

struct UMessageUnion {
  UMessage type;
  void *value;

  UMessageUnion() : type(UMessage_NONE), value(nullptr) {}
  UMessageUnion(UMessageUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(UMessage_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  UMessageUnion(const UMessageUnion &) FLATBUFFERS_NOEXCEPT;
  UMessageUnion &operator=(const UMessageUnion &u) FLATBUFFERS_NOEXCEPT
    { UMessageUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  UMessageUnion &operator=(UMessageUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~UMessageUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = UMessageTraits<typename RT::TableType>::enum_value;
    if (type != UMessage_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, UMessage type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  game::StatusT *Asstatus() {
    return type == UMessage_status ?
      reinterpret_cast<game::StatusT *>(value) : nullptr;
  }
  const game::StatusT *Asstatus() const {
    return type == UMessage_status ?
      reinterpret_cast<const game::StatusT *>(value) : nullptr;
  }
  ShipT *Asship() {
    return type == UMessage_ship ?
      reinterpret_cast<ShipT *>(value) : nullptr;
  }
  const ShipT *Asship() const {
    return type == UMessage_ship ?
      reinterpret_cast<const ShipT *>(value) : nullptr;
  }
  PartT *Aspart() {
    return type == UMessage_part ?
      reinterpret_cast<PartT *>(value) : nullptr;
  }
  const PartT *Aspart() const {
    return type == UMessage_part ?
      reinterpret_cast<const PartT *>(value) : nullptr;
  }
};

bool VerifyUMessage(flatbuffers::Verifier &verifier, const void *obj, UMessage type);
bool VerifyUMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct MessageT : public flatbuffers::NativeTable {
  typedef Message TableType;
  UMessageUnion oneof;
  MessageT() {
  }
};

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ONEOF_TYPE = 4,
    VT_ONEOF = 6
  };
  UMessage oneof_type() const {
    return static_cast<UMessage>(GetField<uint8_t>(VT_ONEOF_TYPE, 0));
  }
  const void *oneof() const {
    return GetPointer<const void *>(VT_ONEOF);
  }
  template<typename T> const T *oneof_as() const;
  const game::Status *oneof_as_status() const {
    return oneof_type() == UMessage_status ? static_cast<const game::Status *>(oneof()) : nullptr;
  }
  const Ship *oneof_as_ship() const {
    return oneof_type() == UMessage_ship ? static_cast<const Ship *>(oneof()) : nullptr;
  }
  const Part *oneof_as_part() const {
    return oneof_type() == UMessage_part ? static_cast<const Part *>(oneof()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ONEOF_TYPE) &&
           VerifyOffset(verifier, VT_ONEOF) &&
           VerifyUMessage(verifier, oneof(), oneof_type()) &&
           verifier.EndTable();
  }
  MessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Message> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const game::Status *Message::oneof_as<game::Status>() const {
  return oneof_as_status();
}

template<> inline const Ship *Message::oneof_as<Ship>() const {
  return oneof_as_ship();
}

template<> inline const Part *Message::oneof_as<Part>() const {
  return oneof_as_part();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_oneof_type(UMessage oneof_type) {
    fbb_.AddElement<uint8_t>(Message::VT_ONEOF_TYPE, static_cast<uint8_t>(oneof_type), 0);
  }
  void add_oneof(flatbuffers::Offset<void> oneof) {
    fbb_.AddOffset(Message::VT_ONEOF, oneof);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    UMessage oneof_type = UMessage_NONE,
    flatbuffers::Offset<void> oneof = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_oneof(oneof);
  builder_.add_oneof_type(oneof_type);
  return builder_.Finish();
}

flatbuffers::Offset<Message> CreateMessage(flatbuffers::FlatBufferBuilder &_fbb, const MessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShipT : public flatbuffers::NativeTable {
  typedef Ship TableType;
  Type action;
  std::unique_ptr<game::ShipT> ship;
  uint8_t dest_user;
  ShipT()
      : action(Type_give),
        dest_user(0) {
  }
};

struct Ship FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShipT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION = 4,
    VT_SHIP = 6,
    VT_DEST_USER = 8
  };
  Type action() const {
    return static_cast<Type>(GetField<uint8_t>(VT_ACTION, 0));
  }
  const game::Ship *ship() const {
    return GetPointer<const game::Ship *>(VT_SHIP);
  }
  uint8_t dest_user() const {
    return GetField<uint8_t>(VT_DEST_USER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACTION) &&
           VerifyOffset(verifier, VT_SHIP) &&
           verifier.VerifyTable(ship()) &&
           VerifyField<uint8_t>(verifier, VT_DEST_USER) &&
           verifier.EndTable();
  }
  ShipT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShipT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Ship> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShipT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShipBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_action(Type action) {
    fbb_.AddElement<uint8_t>(Ship::VT_ACTION, static_cast<uint8_t>(action), 0);
  }
  void add_ship(flatbuffers::Offset<game::Ship> ship) {
    fbb_.AddOffset(Ship::VT_SHIP, ship);
  }
  void add_dest_user(uint8_t dest_user) {
    fbb_.AddElement<uint8_t>(Ship::VT_DEST_USER, dest_user, 0);
  }
  explicit ShipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShipBuilder &operator=(const ShipBuilder &);
  flatbuffers::Offset<Ship> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ship>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ship> CreateShip(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type action = Type_give,
    flatbuffers::Offset<game::Ship> ship = 0,
    uint8_t dest_user = 0) {
  ShipBuilder builder_(_fbb);
  builder_.add_ship(ship);
  builder_.add_dest_user(dest_user);
  builder_.add_action(action);
  return builder_.Finish();
}

flatbuffers::Offset<Ship> CreateShip(flatbuffers::FlatBufferBuilder &_fbb, const ShipT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartT : public flatbuffers::NativeTable {
  typedef Part TableType;
  Type action;
  std::unique_ptr<game::ShipPartT> part;
  uint8_t dest_user;
  PartT()
      : action(Type_give),
        dest_user(0) {
  }
};

struct Part FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION = 4,
    VT_PART = 6,
    VT_DEST_USER = 8
  };
  Type action() const {
    return static_cast<Type>(GetField<uint8_t>(VT_ACTION, 0));
  }
  const game::ShipPart *part() const {
    return GetPointer<const game::ShipPart *>(VT_PART);
  }
  uint8_t dest_user() const {
    return GetField<uint8_t>(VT_DEST_USER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACTION) &&
           VerifyOffset(verifier, VT_PART) &&
           verifier.VerifyTable(part()) &&
           VerifyField<uint8_t>(verifier, VT_DEST_USER) &&
           verifier.EndTable();
  }
  PartT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Part> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_action(Type action) {
    fbb_.AddElement<uint8_t>(Part::VT_ACTION, static_cast<uint8_t>(action), 0);
  }
  void add_part(flatbuffers::Offset<game::ShipPart> part) {
    fbb_.AddOffset(Part::VT_PART, part);
  }
  void add_dest_user(uint8_t dest_user) {
    fbb_.AddElement<uint8_t>(Part::VT_DEST_USER, dest_user, 0);
  }
  explicit PartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PartBuilder &operator=(const PartBuilder &);
  flatbuffers::Offset<Part> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Part>(end);
    return o;
  }
};

inline flatbuffers::Offset<Part> CreatePart(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type action = Type_give,
    flatbuffers::Offset<game::ShipPart> part = 0,
    uint8_t dest_user = 0) {
  PartBuilder builder_(_fbb);
  builder_.add_part(part);
  builder_.add_dest_user(dest_user);
  builder_.add_action(action);
  return builder_.Finish();
}

flatbuffers::Offset<Part> CreatePart(flatbuffers::FlatBufferBuilder &_fbb, const PartT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline MessageT *Message::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MessageT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Message::UnPackTo(MessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = oneof_type(); _o->oneof.type = _e; };
  { auto _e = oneof(); if (_e) _o->oneof.value = UMessageUnion::UnPack(_e, oneof_type(), _resolver); };
}

inline flatbuffers::Offset<Message> Message::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Message> CreateMessage(flatbuffers::FlatBufferBuilder &_fbb, const MessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _oneof_type = _o->oneof.type;
  auto _oneof = _o->oneof.Pack(_fbb);
  return message::CreateMessage(
      _fbb,
      _oneof_type,
      _oneof);
}

inline ShipT *Ship::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ShipT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Ship::UnPackTo(ShipT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = action(); _o->action = _e; };
  { auto _e = ship(); if (_e) _o->ship = std::unique_ptr<game::ShipT>(_e->UnPack(_resolver)); };
  { auto _e = dest_user(); _o->dest_user = _e; };
}

inline flatbuffers::Offset<Ship> Ship::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShipT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShip(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Ship> CreateShip(flatbuffers::FlatBufferBuilder &_fbb, const ShipT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShipT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _action = _o->action;
  auto _ship = _o->ship ? CreateShip(_fbb, _o->ship.get(), _rehasher) : 0;
  auto _dest_user = _o->dest_user;
  return message::CreateShip(
      _fbb,
      _action,
      _ship,
      _dest_user);
}

inline PartT *Part::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PartT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Part::UnPackTo(PartT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = action(); _o->action = _e; };
  { auto _e = part(); if (_e) _o->part = std::unique_ptr<game::ShipPartT>(_e->UnPack(_resolver)); };
  { auto _e = dest_user(); _o->dest_user = _e; };
}

inline flatbuffers::Offset<Part> Part::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePart(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Part> CreatePart(flatbuffers::FlatBufferBuilder &_fbb, const PartT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _action = _o->action;
  auto _part = _o->part ? CreateShipPart(_fbb, _o->part.get(), _rehasher) : 0;
  auto _dest_user = _o->dest_user;
  return message::CreatePart(
      _fbb,
      _action,
      _part,
      _dest_user);
}

inline bool VerifyUMessage(flatbuffers::Verifier &verifier, const void *obj, UMessage type) {
  switch (type) {
    case UMessage_NONE: {
      return true;
    }
    case UMessage_status: {
      auto ptr = reinterpret_cast<const game::Status *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UMessage_ship: {
      auto ptr = reinterpret_cast<const Ship *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case UMessage_part: {
      auto ptr = reinterpret_cast<const Part *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyUMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyUMessage(
        verifier,  values->Get(i), types->GetEnum<UMessage>(i))) {
      return false;
    }
  }
  return true;
}

inline void *UMessageUnion::UnPack(const void *obj, UMessage type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case UMessage_status: {
      auto ptr = reinterpret_cast<const game::Status *>(obj);
      return ptr->UnPack(resolver);
    }
    case UMessage_ship: {
      auto ptr = reinterpret_cast<const Ship *>(obj);
      return ptr->UnPack(resolver);
    }
    case UMessage_part: {
      auto ptr = reinterpret_cast<const Part *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> UMessageUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case UMessage_status: {
      auto ptr = reinterpret_cast<const game::StatusT *>(value);
      return CreateStatus(_fbb, ptr, _rehasher).Union();
    }
    case UMessage_ship: {
      auto ptr = reinterpret_cast<const ShipT *>(value);
      return CreateShip(_fbb, ptr, _rehasher).Union();
    }
    case UMessage_part: {
      auto ptr = reinterpret_cast<const PartT *>(value);
      return CreatePart(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline UMessageUnion::UMessageUnion(const UMessageUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case UMessage_status: {
      value = new game::StatusT(*reinterpret_cast<game::StatusT *>(u.value));
      break;
    }
    case UMessage_ship: {
      FLATBUFFERS_ASSERT(false);  // ShipT not copyable.
      break;
    }
    case UMessage_part: {
      FLATBUFFERS_ASSERT(false);  // PartT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void UMessageUnion::Reset() {
  switch (type) {
    case UMessage_status: {
      auto ptr = reinterpret_cast<game::StatusT *>(value);
      delete ptr;
      break;
    }
    case UMessage_ship: {
      auto ptr = reinterpret_cast<ShipT *>(value);
      delete ptr;
      break;
    }
    case UMessage_part: {
      auto ptr = reinterpret_cast<PartT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = UMessage_NONE;
}

inline const message::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<message::Message>(buf);
}

inline const message::Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<message::Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<message::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<message::Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<message::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<message::Message> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<MessageT> UnPackMessage(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<MessageT>(GetMessage(buf)->UnPack(res));
}

}  // namespace message

#endif  // FLATBUFFERS_GENERATED_MESSAGE_MESSAGE_H_
