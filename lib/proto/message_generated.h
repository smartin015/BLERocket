// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGE_MESSAGE_H_
#define FLATBUFFERS_GENERATED_MESSAGE_MESSAGE_H_

#include "flatbuffers/flatbuffers.h"

#include "game_generated.h"
#include "nav_generated.h"

namespace message {

struct Status;
struct StatusT;

struct Ship;
struct ShipT;

struct Part;
struct PartT;

enum Type {
  Type_give = 0,
  Type_race = 1,
  Type_trade = 2,
  Type_explore = 3,
  Type_score = 4,
  Type_MIN = Type_give,
  Type_MAX = Type_score
};

inline const Type (&EnumValuesType())[5] {
  static const Type values[] = {
    Type_give,
    Type_race,
    Type_trade,
    Type_explore,
    Type_score
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[] = {
    "give",
    "race",
    "trade",
    "explore",
    "score",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (e < Type_give || e > Type_score) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

enum Message {
  Message_NONE = 0,
  Message_status = 1,
  Message_ship = 2,
  Message_part = 3,
  Message_MIN = Message_NONE,
  Message_MAX = Message_part
};

inline const Message (&EnumValuesMessage())[4] {
  static const Message values[] = {
    Message_NONE,
    Message_status,
    Message_ship,
    Message_part
  };
  return values;
}

inline const char * const *EnumNamesMessage() {
  static const char * const names[] = {
    "NONE",
    "status",
    "ship",
    "part",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  if (e < Message_NONE || e > Message_part) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<Status> {
  static const Message enum_value = Message_status;
};

template<> struct MessageTraits<Ship> {
  static const Message enum_value = Message_ship;
};

template<> struct MessageTraits<Part> {
  static const Message enum_value = Message_part;
};

struct MessageUnion {
  Message type;
  void *value;

  MessageUnion() : type(Message_NONE), value(nullptr) {}
  MessageUnion(MessageUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Message_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MessageUnion(const MessageUnion &) FLATBUFFERS_NOEXCEPT;
  MessageUnion &operator=(const MessageUnion &u) FLATBUFFERS_NOEXCEPT
    { MessageUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MessageUnion &operator=(MessageUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MessageUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = MessageTraits<typename RT::TableType>::enum_value;
    if (type != Message_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Message type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  StatusT *Asstatus() {
    return type == Message_status ?
      reinterpret_cast<StatusT *>(value) : nullptr;
  }
  const StatusT *Asstatus() const {
    return type == Message_status ?
      reinterpret_cast<const StatusT *>(value) : nullptr;
  }
  ShipT *Asship() {
    return type == Message_ship ?
      reinterpret_cast<ShipT *>(value) : nullptr;
  }
  const ShipT *Asship() const {
    return type == Message_ship ?
      reinterpret_cast<const ShipT *>(value) : nullptr;
  }
  PartT *Aspart() {
    return type == Message_part ?
      reinterpret_cast<PartT *>(value) : nullptr;
  }
  const PartT *Aspart() const {
    return type == Message_part ?
      reinterpret_cast<const PartT *>(value) : nullptr;
  }
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct StatusT : public flatbuffers::NativeTable {
  typedef Status TableType;
  uint8_t firmwareVersion;
  std::unique_ptr<game::UserT> user;
  uint8_t site;
  std::unique_ptr<game::PhaseT> phase;
  uint16_t score;
  uint16_t reputation;
  StatusT()
      : firmwareVersion(0),
        site(0),
        score(0),
        reputation(0) {
  }
};

struct Status FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIRMWAREVERSION = 4,
    VT_USER = 6,
    VT_SITE = 8,
    VT_PHASE = 10,
    VT_SCORE = 12,
    VT_REPUTATION = 14
  };
  uint8_t firmwareVersion() const {
    return GetField<uint8_t>(VT_FIRMWAREVERSION, 0);
  }
  const game::User *user() const {
    return GetPointer<const game::User *>(VT_USER);
  }
  uint8_t site() const {
    return GetField<uint8_t>(VT_SITE, 0);
  }
  const game::Phase *phase() const {
    return GetPointer<const game::Phase *>(VT_PHASE);
  }
  uint16_t score() const {
    return GetField<uint16_t>(VT_SCORE, 0);
  }
  uint16_t reputation() const {
    return GetField<uint16_t>(VT_REPUTATION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FIRMWAREVERSION) &&
           VerifyOffset(verifier, VT_USER) &&
           verifier.VerifyTable(user()) &&
           VerifyField<uint8_t>(verifier, VT_SITE) &&
           VerifyOffset(verifier, VT_PHASE) &&
           verifier.VerifyTable(phase()) &&
           VerifyField<uint16_t>(verifier, VT_SCORE) &&
           VerifyField<uint16_t>(verifier, VT_REPUTATION) &&
           verifier.EndTable();
  }
  StatusT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StatusT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Status> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatusT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StatusBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_firmwareVersion(uint8_t firmwareVersion) {
    fbb_.AddElement<uint8_t>(Status::VT_FIRMWAREVERSION, firmwareVersion, 0);
  }
  void add_user(flatbuffers::Offset<game::User> user) {
    fbb_.AddOffset(Status::VT_USER, user);
  }
  void add_site(uint8_t site) {
    fbb_.AddElement<uint8_t>(Status::VT_SITE, site, 0);
  }
  void add_phase(flatbuffers::Offset<game::Phase> phase) {
    fbb_.AddOffset(Status::VT_PHASE, phase);
  }
  void add_score(uint16_t score) {
    fbb_.AddElement<uint16_t>(Status::VT_SCORE, score, 0);
  }
  void add_reputation(uint16_t reputation) {
    fbb_.AddElement<uint16_t>(Status::VT_REPUTATION, reputation, 0);
  }
  explicit StatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StatusBuilder &operator=(const StatusBuilder &);
  flatbuffers::Offset<Status> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Status>(end);
    return o;
  }
};

inline flatbuffers::Offset<Status> CreateStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t firmwareVersion = 0,
    flatbuffers::Offset<game::User> user = 0,
    uint8_t site = 0,
    flatbuffers::Offset<game::Phase> phase = 0,
    uint16_t score = 0,
    uint16_t reputation = 0) {
  StatusBuilder builder_(_fbb);
  builder_.add_phase(phase);
  builder_.add_user(user);
  builder_.add_reputation(reputation);
  builder_.add_score(score);
  builder_.add_site(site);
  builder_.add_firmwareVersion(firmwareVersion);
  return builder_.Finish();
}

flatbuffers::Offset<Status> CreateStatus(flatbuffers::FlatBufferBuilder &_fbb, const StatusT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShipT : public flatbuffers::NativeTable {
  typedef Ship TableType;
  Type action;
  std::unique_ptr<game::ShipT> ship;
  std::unique_ptr<game::UserT> dest;
  ShipT()
      : action(Type_give) {
  }
};

struct Ship FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShipT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION = 4,
    VT_SHIP = 6,
    VT_DEST = 8
  };
  Type action() const {
    return static_cast<Type>(GetField<uint8_t>(VT_ACTION, 0));
  }
  const game::Ship *ship() const {
    return GetPointer<const game::Ship *>(VT_SHIP);
  }
  const game::User *dest() const {
    return GetPointer<const game::User *>(VT_DEST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACTION) &&
           VerifyOffset(verifier, VT_SHIP) &&
           verifier.VerifyTable(ship()) &&
           VerifyOffset(verifier, VT_DEST) &&
           verifier.VerifyTable(dest()) &&
           verifier.EndTable();
  }
  ShipT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShipT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Ship> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShipT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShipBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_action(Type action) {
    fbb_.AddElement<uint8_t>(Ship::VT_ACTION, static_cast<uint8_t>(action), 0);
  }
  void add_ship(flatbuffers::Offset<game::Ship> ship) {
    fbb_.AddOffset(Ship::VT_SHIP, ship);
  }
  void add_dest(flatbuffers::Offset<game::User> dest) {
    fbb_.AddOffset(Ship::VT_DEST, dest);
  }
  explicit ShipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShipBuilder &operator=(const ShipBuilder &);
  flatbuffers::Offset<Ship> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ship>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ship> CreateShip(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type action = Type_give,
    flatbuffers::Offset<game::Ship> ship = 0,
    flatbuffers::Offset<game::User> dest = 0) {
  ShipBuilder builder_(_fbb);
  builder_.add_dest(dest);
  builder_.add_ship(ship);
  builder_.add_action(action);
  return builder_.Finish();
}

flatbuffers::Offset<Ship> CreateShip(flatbuffers::FlatBufferBuilder &_fbb, const ShipT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartT : public flatbuffers::NativeTable {
  typedef Part TableType;
  Type action;
  std::unique_ptr<game::ShipPartT> part;
  uint8_t quality;
  std::unique_ptr<game::UserT> dest;
  PartT()
      : action(Type_give),
        quality(0) {
  }
};

struct Part FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTION = 4,
    VT_PART = 6,
    VT_QUALITY = 8,
    VT_DEST = 10
  };
  Type action() const {
    return static_cast<Type>(GetField<uint8_t>(VT_ACTION, 0));
  }
  const game::ShipPart *part() const {
    return GetPointer<const game::ShipPart *>(VT_PART);
  }
  uint8_t quality() const {
    return GetField<uint8_t>(VT_QUALITY, 0);
  }
  const game::User *dest() const {
    return GetPointer<const game::User *>(VT_DEST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ACTION) &&
           VerifyOffset(verifier, VT_PART) &&
           verifier.VerifyTable(part()) &&
           VerifyField<uint8_t>(verifier, VT_QUALITY) &&
           VerifyOffset(verifier, VT_DEST) &&
           verifier.VerifyTable(dest()) &&
           verifier.EndTable();
  }
  PartT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Part> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_action(Type action) {
    fbb_.AddElement<uint8_t>(Part::VT_ACTION, static_cast<uint8_t>(action), 0);
  }
  void add_part(flatbuffers::Offset<game::ShipPart> part) {
    fbb_.AddOffset(Part::VT_PART, part);
  }
  void add_quality(uint8_t quality) {
    fbb_.AddElement<uint8_t>(Part::VT_QUALITY, quality, 0);
  }
  void add_dest(flatbuffers::Offset<game::User> dest) {
    fbb_.AddOffset(Part::VT_DEST, dest);
  }
  explicit PartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PartBuilder &operator=(const PartBuilder &);
  flatbuffers::Offset<Part> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Part>(end);
    return o;
  }
};

inline flatbuffers::Offset<Part> CreatePart(
    flatbuffers::FlatBufferBuilder &_fbb,
    Type action = Type_give,
    flatbuffers::Offset<game::ShipPart> part = 0,
    uint8_t quality = 0,
    flatbuffers::Offset<game::User> dest = 0) {
  PartBuilder builder_(_fbb);
  builder_.add_dest(dest);
  builder_.add_part(part);
  builder_.add_quality(quality);
  builder_.add_action(action);
  return builder_.Finish();
}

flatbuffers::Offset<Part> CreatePart(flatbuffers::FlatBufferBuilder &_fbb, const PartT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline StatusT *Status::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StatusT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Status::UnPackTo(StatusT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = firmwareVersion(); _o->firmwareVersion = _e; };
  { auto _e = user(); if (_e) _o->user = std::unique_ptr<game::UserT>(_e->UnPack(_resolver)); };
  { auto _e = site(); _o->site = _e; };
  { auto _e = phase(); if (_e) _o->phase = std::unique_ptr<game::PhaseT>(_e->UnPack(_resolver)); };
  { auto _e = score(); _o->score = _e; };
  { auto _e = reputation(); _o->reputation = _e; };
}

inline flatbuffers::Offset<Status> Status::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatusT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStatus(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Status> CreateStatus(flatbuffers::FlatBufferBuilder &_fbb, const StatusT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StatusT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _firmwareVersion = _o->firmwareVersion;
  auto _user = _o->user ? CreateUser(_fbb, _o->user.get(), _rehasher) : 0;
  auto _site = _o->site;
  auto _phase = _o->phase ? CreatePhase(_fbb, _o->phase.get(), _rehasher) : 0;
  auto _score = _o->score;
  auto _reputation = _o->reputation;
  return message::CreateStatus(
      _fbb,
      _firmwareVersion,
      _user,
      _site,
      _phase,
      _score,
      _reputation);
}

inline ShipT *Ship::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ShipT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Ship::UnPackTo(ShipT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = action(); _o->action = _e; };
  { auto _e = ship(); if (_e) _o->ship = std::unique_ptr<game::ShipT>(_e->UnPack(_resolver)); };
  { auto _e = dest(); if (_e) _o->dest = std::unique_ptr<game::UserT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Ship> Ship::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShipT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShip(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Ship> CreateShip(flatbuffers::FlatBufferBuilder &_fbb, const ShipT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShipT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _action = _o->action;
  auto _ship = _o->ship ? CreateShip(_fbb, _o->ship.get(), _rehasher) : 0;
  auto _dest = _o->dest ? CreateUser(_fbb, _o->dest.get(), _rehasher) : 0;
  return message::CreateShip(
      _fbb,
      _action,
      _ship,
      _dest);
}

inline PartT *Part::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PartT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Part::UnPackTo(PartT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = action(); _o->action = _e; };
  { auto _e = part(); if (_e) _o->part = std::unique_ptr<game::ShipPartT>(_e->UnPack(_resolver)); };
  { auto _e = quality(); _o->quality = _e; };
  { auto _e = dest(); if (_e) _o->dest = std::unique_ptr<game::UserT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<Part> Part::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePart(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Part> CreatePart(flatbuffers::FlatBufferBuilder &_fbb, const PartT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _action = _o->action;
  auto _part = _o->part ? CreateShipPart(_fbb, _o->part.get(), _rehasher) : 0;
  auto _quality = _o->quality;
  auto _dest = _o->dest ? CreateUser(_fbb, _o->dest.get(), _rehasher) : 0;
  return message::CreatePart(
      _fbb,
      _action,
      _part,
      _quality,
      _dest);
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_status: {
      auto ptr = reinterpret_cast<const Status *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ship: {
      auto ptr = reinterpret_cast<const Ship *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_part: {
      auto ptr = reinterpret_cast<const Part *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MessageUnion::UnPack(const void *obj, Message type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Message_status: {
      auto ptr = reinterpret_cast<const Status *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_ship: {
      auto ptr = reinterpret_cast<const Ship *>(obj);
      return ptr->UnPack(resolver);
    }
    case Message_part: {
      auto ptr = reinterpret_cast<const Part *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MessageUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Message_status: {
      auto ptr = reinterpret_cast<const StatusT *>(value);
      return CreateStatus(_fbb, ptr, _rehasher).Union();
    }
    case Message_ship: {
      auto ptr = reinterpret_cast<const ShipT *>(value);
      return CreateShip(_fbb, ptr, _rehasher).Union();
    }
    case Message_part: {
      auto ptr = reinterpret_cast<const PartT *>(value);
      return CreatePart(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MessageUnion::MessageUnion(const MessageUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case Message_status: {
      FLATBUFFERS_ASSERT(false);  // StatusT not copyable.
      break;
    }
    case Message_ship: {
      FLATBUFFERS_ASSERT(false);  // ShipT not copyable.
      break;
    }
    case Message_part: {
      FLATBUFFERS_ASSERT(false);  // PartT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void MessageUnion::Reset() {
  switch (type) {
    case Message_status: {
      auto ptr = reinterpret_cast<StatusT *>(value);
      delete ptr;
      break;
    }
    case Message_ship: {
      auto ptr = reinterpret_cast<ShipT *>(value);
      delete ptr;
      break;
    }
    case Message_part: {
      auto ptr = reinterpret_cast<PartT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Message_NONE;
}

}  // namespace message

#endif  // FLATBUFFERS_GENERATED_MESSAGE_MESSAGE_H_
