// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GAME_GAME_H_
#define FLATBUFFERS_GENERATED_GAME_GAME_H_

#include "flatbuffers/flatbuffers.h"

#include "nav_generated.h"

namespace game {

struct ShipPart;
struct ShipPartT;

struct Ship;
struct ShipT;

struct Phase;
struct PhaseT;

struct State;
struct StateT;

enum ShipPartType {
  ShipPartType_hull = 0,
  ShipPartType_thruster = 1,
  ShipPartType_cargo = 2,
  ShipPartType_sensors = 3,
  ShipPartType_MIN = ShipPartType_hull,
  ShipPartType_MAX = ShipPartType_sensors
};

inline const ShipPartType (&EnumValuesShipPartType())[4] {
  static const ShipPartType values[] = {
    ShipPartType_hull,
    ShipPartType_thruster,
    ShipPartType_cargo,
    ShipPartType_sensors
  };
  return values;
}

inline const char * const *EnumNamesShipPartType() {
  static const char * const names[] = {
    "hull",
    "thruster",
    "cargo",
    "sensors",
    nullptr
  };
  return names;
}

inline const char *EnumNameShipPartType(ShipPartType e) {
  if (e < ShipPartType_hull || e > ShipPartType_sensors) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesShipPartType()[index];
}

struct ShipPartT : public flatbuffers::NativeTable {
  typedef ShipPart TableType;
  ShipPartType type;
  uint8_t quality;
  ShipPartT()
      : type(ShipPartType_hull),
        quality(0) {
  }
};

struct ShipPart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShipPartT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_QUALITY = 6
  };
  ShipPartType type() const {
    return static_cast<ShipPartType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint8_t quality() const {
    return GetField<uint8_t>(VT_QUALITY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_QUALITY) &&
           verifier.EndTable();
  }
  ShipPartT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShipPartT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ShipPart> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShipPartT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShipPartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ShipPartType type) {
    fbb_.AddElement<int8_t>(ShipPart::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_quality(uint8_t quality) {
    fbb_.AddElement<uint8_t>(ShipPart::VT_QUALITY, quality, 0);
  }
  explicit ShipPartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShipPartBuilder &operator=(const ShipPartBuilder &);
  flatbuffers::Offset<ShipPart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShipPart>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShipPart> CreateShipPart(
    flatbuffers::FlatBufferBuilder &_fbb,
    ShipPartType type = ShipPartType_hull,
    uint8_t quality = 0) {
  ShipPartBuilder builder_(_fbb);
  builder_.add_quality(quality);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<ShipPart> CreateShipPart(flatbuffers::FlatBufferBuilder &_fbb, const ShipPartT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ShipT : public flatbuffers::NativeTable {
  typedef Ship TableType;
  std::string name;
  std::vector<std::unique_ptr<ShipPartT>> parts;
  std::vector<uint8_t> creators;
  uint8_t owner;
  ShipT()
      : owner(0) {
  }
};

struct Ship FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShipT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_PARTS = 6,
    VT_CREATORS = 8,
    VT_OWNER = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ShipPart>> *parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShipPart>> *>(VT_PARTS);
  }
  const flatbuffers::Vector<uint8_t> *creators() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CREATORS);
  }
  uint8_t owner() const {
    return GetField<uint8_t>(VT_OWNER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PARTS) &&
           verifier.VerifyVector(parts()) &&
           verifier.VerifyVectorOfTables(parts()) &&
           VerifyOffset(verifier, VT_CREATORS) &&
           verifier.VerifyVector(creators()) &&
           VerifyField<uint8_t>(verifier, VT_OWNER) &&
           verifier.EndTable();
  }
  ShipT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ShipT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Ship> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShipT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ShipBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Ship::VT_NAME, name);
  }
  void add_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShipPart>>> parts) {
    fbb_.AddOffset(Ship::VT_PARTS, parts);
  }
  void add_creators(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> creators) {
    fbb_.AddOffset(Ship::VT_CREATORS, creators);
  }
  void add_owner(uint8_t owner) {
    fbb_.AddElement<uint8_t>(Ship::VT_OWNER, owner, 0);
  }
  explicit ShipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShipBuilder &operator=(const ShipBuilder &);
  flatbuffers::Offset<Ship> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ship>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ship> CreateShip(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShipPart>>> parts = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> creators = 0,
    uint8_t owner = 0) {
  ShipBuilder builder_(_fbb);
  builder_.add_creators(creators);
  builder_.add_parts(parts);
  builder_.add_name(name);
  builder_.add_owner(owner);
  return builder_.Finish();
}

inline flatbuffers::Offset<Ship> CreateShipDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<ShipPart>> *parts = nullptr,
    const std::vector<uint8_t> *creators = nullptr,
    uint8_t owner = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto parts__ = parts ? _fbb.CreateVector<flatbuffers::Offset<ShipPart>>(*parts) : 0;
  auto creators__ = creators ? _fbb.CreateVector<uint8_t>(*creators) : 0;
  return game::CreateShip(
      _fbb,
      name__,
      parts__,
      creators__,
      owner);
}

flatbuffers::Offset<Ship> CreateShip(flatbuffers::FlatBufferBuilder &_fbb, const ShipT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PhaseT : public flatbuffers::NativeTable {
  typedef Phase TableType;
  uint8_t id;
  uint8_t txn;
  PhaseT()
      : id(0),
        txn(0) {
  }
};

struct Phase FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PhaseT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TXN = 6
  };
  uint8_t id() const {
    return GetField<uint8_t>(VT_ID, 0);
  }
  uint8_t txn() const {
    return GetField<uint8_t>(VT_TXN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_TXN) &&
           verifier.EndTable();
  }
  PhaseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PhaseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Phase> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PhaseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PhaseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint8_t id) {
    fbb_.AddElement<uint8_t>(Phase::VT_ID, id, 0);
  }
  void add_txn(uint8_t txn) {
    fbb_.AddElement<uint8_t>(Phase::VT_TXN, txn, 0);
  }
  explicit PhaseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PhaseBuilder &operator=(const PhaseBuilder &);
  flatbuffers::Offset<Phase> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Phase>(end);
    return o;
  }
};

inline flatbuffers::Offset<Phase> CreatePhase(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t id = 0,
    uint8_t txn = 0) {
  PhaseBuilder builder_(_fbb);
  builder_.add_txn(txn);
  builder_.add_id(id);
  return builder_.Finish();
}

flatbuffers::Offset<Phase> CreatePhase(flatbuffers::FlatBufferBuilder &_fbb, const PhaseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StateT : public flatbuffers::NativeTable {
  typedef State TableType;
  nav::Page page;
  std::vector<std::unique_ptr<ShipPartT>> parts;
  std::vector<std::unique_ptr<ShipT>> ships;
  StateT()
      : page(nav::Page_main) {
  }
};

struct State FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StateT NativeTableType;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PAGE = 4,
    VT_PARTS = 6,
    VT_SHIPS = 8
  };
  nav::Page page() const {
    return static_cast<nav::Page>(GetField<int8_t>(VT_PAGE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<ShipPart>> *parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShipPart>> *>(VT_PARTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Ship>> *ships() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Ship>> *>(VT_SHIPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PAGE) &&
           VerifyOffset(verifier, VT_PARTS) &&
           verifier.VerifyVector(parts()) &&
           verifier.VerifyVectorOfTables(parts()) &&
           VerifyOffset(verifier, VT_SHIPS) &&
           verifier.VerifyVector(ships()) &&
           verifier.VerifyVectorOfTables(ships()) &&
           verifier.EndTable();
  }
  StateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<State> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_page(nav::Page page) {
    fbb_.AddElement<int8_t>(State::VT_PAGE, static_cast<int8_t>(page), 0);
  }
  void add_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShipPart>>> parts) {
    fbb_.AddOffset(State::VT_PARTS, parts);
  }
  void add_ships(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ship>>> ships) {
    fbb_.AddOffset(State::VT_SHIPS, ships);
  }
  explicit StateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StateBuilder &operator=(const StateBuilder &);
  flatbuffers::Offset<State> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<State>(end);
    return o;
  }
};

inline flatbuffers::Offset<State> CreateState(
    flatbuffers::FlatBufferBuilder &_fbb,
    nav::Page page = nav::Page_main,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShipPart>>> parts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Ship>>> ships = 0) {
  StateBuilder builder_(_fbb);
  builder_.add_ships(ships);
  builder_.add_parts(parts);
  builder_.add_page(page);
  return builder_.Finish();
}

inline flatbuffers::Offset<State> CreateStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    nav::Page page = nav::Page_main,
    const std::vector<flatbuffers::Offset<ShipPart>> *parts = nullptr,
    const std::vector<flatbuffers::Offset<Ship>> *ships = nullptr) {
  auto parts__ = parts ? _fbb.CreateVector<flatbuffers::Offset<ShipPart>>(*parts) : 0;
  auto ships__ = ships ? _fbb.CreateVector<flatbuffers::Offset<Ship>>(*ships) : 0;
  return game::CreateState(
      _fbb,
      page,
      parts__,
      ships__);
}

flatbuffers::Offset<State> CreateState(flatbuffers::FlatBufferBuilder &_fbb, const StateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ShipPartT *ShipPart::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ShipPartT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ShipPart::UnPackTo(ShipPartT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = quality(); _o->quality = _e; };
}

inline flatbuffers::Offset<ShipPart> ShipPart::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShipPartT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShipPart(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ShipPart> CreateShipPart(flatbuffers::FlatBufferBuilder &_fbb, const ShipPartT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShipPartT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _quality = _o->quality;
  return game::CreateShipPart(
      _fbb,
      _type,
      _quality);
}

inline ShipT *Ship::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ShipT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Ship::UnPackTo(ShipT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = parts(); if (_e) { _o->parts.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->parts[_i] = std::unique_ptr<ShipPartT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = creators(); if (_e) { _o->creators.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->creators[_i] = _e->Get(_i); } } };
  { auto _e = owner(); _o->owner = _e; };
}

inline flatbuffers::Offset<Ship> Ship::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ShipT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateShip(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Ship> CreateShip(flatbuffers::FlatBufferBuilder &_fbb, const ShipT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ShipT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _parts = _o->parts.size() ? _fbb.CreateVector<flatbuffers::Offset<ShipPart>> (_o->parts.size(), [](size_t i, _VectorArgs *__va) { return CreateShipPart(*__va->__fbb, __va->__o->parts[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _creators = _o->creators.size() ? _fbb.CreateVector(_o->creators) : 0;
  auto _owner = _o->owner;
  return game::CreateShip(
      _fbb,
      _name,
      _parts,
      _creators,
      _owner);
}

inline PhaseT *Phase::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PhaseT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Phase::UnPackTo(PhaseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; };
  { auto _e = txn(); _o->txn = _e; };
}

inline flatbuffers::Offset<Phase> Phase::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PhaseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePhase(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Phase> CreatePhase(flatbuffers::FlatBufferBuilder &_fbb, const PhaseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PhaseT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _txn = _o->txn;
  return game::CreatePhase(
      _fbb,
      _id,
      _txn);
}

inline StateT *State::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new StateT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void State::UnPackTo(StateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = page(); _o->page = _e; };
  { auto _e = parts(); if (_e) { _o->parts.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->parts[_i] = std::unique_ptr<ShipPartT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = ships(); if (_e) { _o->ships.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ships[_i] = std::unique_ptr<ShipT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<State> State::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<State> CreateState(flatbuffers::FlatBufferBuilder &_fbb, const StateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _page = _o->page;
  auto _parts = _o->parts.size() ? _fbb.CreateVector<flatbuffers::Offset<ShipPart>> (_o->parts.size(), [](size_t i, _VectorArgs *__va) { return CreateShipPart(*__va->__fbb, __va->__o->parts[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _ships = _o->ships.size() ? _fbb.CreateVector<flatbuffers::Offset<Ship>> (_o->ships.size(), [](size_t i, _VectorArgs *__va) { return CreateShip(*__va->__fbb, __va->__o->ships[i].get(), __va->__rehasher); }, &_va ) : 0;
  return game::CreateState(
      _fbb,
      _page,
      _parts,
      _ships);
}

inline const game::State *GetState(const void *buf) {
  return flatbuffers::GetRoot<game::State>(buf);
}

inline const game::State *GetSizePrefixedState(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<game::State>(buf);
}

inline bool VerifyStateBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<game::State>(nullptr);
}

inline bool VerifySizePrefixedStateBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<game::State>(nullptr);
}

inline void FinishStateBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<game::State> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedStateBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<game::State> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<StateT> UnPackState(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<StateT>(GetState(buf)->UnPack(res));
}

}  // namespace game

#endif  // FLATBUFFERS_GENERATED_GAME_GAME_H_
